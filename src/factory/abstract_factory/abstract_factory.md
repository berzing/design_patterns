#### 我们到底做了些什么？  

我们使用的抽象工厂PizzaIngredientFactory来创建原料家族  
通过抽象工厂PizzaIngredientFactory所提供的接口  
可以创建产品的家族(NYPizzaIngredientFactory与ChicagoPizzaIngredientFactory)  
利用接口PizzaIngredientFactory书写代码  我们的代码将从实际工厂解耦  
以便在不同上下文中实现各式各样的工厂  制造出各种不同的产品  

#### 抽象工厂模式
- 提供一个接口 用于创建相关或依赖对象的家族  而不需要明确指定具体类  
- 设计原则：依赖抽象  不要依赖具体类  
- 依赖倒置原则：尽量依赖抽象  避免依赖具体类型  
- 要点：  
    所有的工厂都是用来封装对象的创建  
    简单工厂虽然不是真正的设计模式  但仍不失为一个简单方法  将客户端程序从具体类解耦  
    工厂方法使用继承  抽象工厂使用对象组合  
    工厂方法允许类将实例化延迟到子类进行  抽象工厂创建相关的子类家族  而不需要依赖他们的具体类  
    针对抽象编程  不要针对具体类编程  

#### 抽象工厂和工厂方法区别
我们发现  抽象工厂PizzaIngredientFactory的每个方法实际上看起来都像是工厂方法  
例如：方法`createDough()`,`createSauce()`等等  
每个方法都被声明成抽象的  
而子类的方法覆盖这些方法来创建某些对象  这就是工厂方法！！！  

区别与相同点：  

1. 抽象工厂和工厂方法都是负责创建对象  但是工厂方法用的是继承  抽象工厂用的是对象的组合  
所以  使用工厂方法创建对象时  需要扩展一个类  并覆盖它的工厂方法  
整个工厂模式其实就是用来创建对象的  通过子类来创建对象 由子类来决定具体类型  
抽象工厂提供一个用来创建一个产品家族的抽象类型  这个类型的子类定义了产品被产生的方法  
要想使用这个工厂  必须先实例化它  
抽象工厂还可以把一群相关产品集合起来  
但是做产品集合功能是有一定代价的  
因为如果需要扩展这组产品(比如新增一个产品)  就必须要改变接口  其对应的子类就也需要进行修改  

2. 抽象工厂经常使用工厂方法来实现具体工厂  
但对于抽象工厂  这些具体工厂只是用来创建产品罢了  

3. 抽象工厂和工厂方法都能将对象的创建封装起来  使应用程序解耦  并降低其对特定实现的依赖  
当你需要创建产品家族或想让制造的相关产品集合起来时  我们可以使用抽象工厂  
当你目前还不知道将来需要实例化哪些具体类时  可以使用工厂方法(通过继承工厂方法并实现工厂方法就好)  